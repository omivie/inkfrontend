<!DOCTYPE html>
<html lang="en-NZ">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse all printing supplies - ink cartridges, toner, printers, drums and accessories. Filter by brand, type, and compatibility.">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:title" content="Shop Ink Cartridges & Toner | InkCartridges.co.nz">
    <meta property="og:description" content="Browse genuine and compatible ink cartridges, toner, and printing supplies. Free NZ shipping over $100.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://inkcartridges.co.nz/html/shop.html">
    <meta property="og:site_name" content="InkCartridges.co.nz">

    <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg">
    <title>Shop Ink Cartridges & Toner NZ | InkCartridges.co.nz</title>

    <!-- Google Analytics 4 (with consent mode) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SDQELG0FGD"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            analytics_storage: localStorage.getItem('cookie_consent') === 'accepted' ? 'granted' : 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-SDQELG0FGD');
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/layout.css">
    <link rel="stylesheet" href="/css/components.css">
    <link rel="stylesheet" href="/css/modern-effects.css">
    <link rel="stylesheet" href="/css/pages.css">
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- ============================================
         HEADER
         ============================================ -->
    <header class="site-header">
        <!-- Main header -->
        <div class="header-main">
            <div class="container">
                <!-- Contact info -->
                <div class="header-contact">
                    <a href="tel:0800465275" class="header-contact__item">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                        0800 INK KART (465 275)
                    </a>
                    <a href="mailto:support@inkcartridges.co.nz" class="header-contact__item">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
                        support@inkcartridges.co.nz
                    </a>
                </div>

                <div class="logo-block">
                    <a href="/html/index.html" class="logo" aria-label="InkCartridges.co.nz Home">
                        <span class="logo__text">Ink<span>Cartridges</span>.co.nz</span>
                    </a>
                    <a href="/html/index.html" class="logo__tagline">Get the full picture on image quality</a>
                </div>

                <!-- Header actions -->
                <div class="header-actions">
                    <a href="/html/account/index.html" class="header-actions__item">
                        <span class="header-actions__icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                        </span>
                        <span>Account</span>
                    </a>
                    <a href="/html/account/favourites.html" class="header-actions__item">
                        <span class="header-actions__icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>
                        </span>
                        <span>Favourites</span>
                    </a>
                    <a href="/html/cart.html" class="header-actions__item">
                        <span class="header-actions__icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/></svg>
                            <span class="cart-badge" id="cart-count">0</span>
                        </span>
                        <span>Cart</span>
                    </a>
                </div>
            </div>
        </div>

        <!-- Primary navigation -->
        <nav class="primary-nav" aria-label="Main navigation">
            <div class="container">
                <button class="nav-toggle" aria-expanded="false" aria-controls="nav-menu">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                    <span class="visually-hidden">Menu</span>
                </button>

                <ul id="nav-menu" class="nav-menu">
                    <li class="nav-menu__item">
                        <a href="/html/index.html" class="nav-menu__link">Home</a>
                    </li>
                    <li class="nav-menu__item">
                        <a href="/html/shop.html" class="nav-menu__link nav-menu__link--active">Shop</a>
                    </li>
                    <li class="nav-menu__item nav-menu__item--mega">
                        <button class="nav-menu__link nav-mega-toggle" type="button"
                                aria-haspopup="true" aria-expanded="false" aria-controls="brands-mega">
                            Ink Cartridge Brands
                            <svg class="nav-menu__arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>
                        </button>
                    </li>
                    <li class="nav-menu__item">
                        <a href="/html/ribbons.html" class="nav-menu__link">Typewriter &amp; Printer Ribbons</a>
                    </li>
                </ul>

                <!-- Search bar -->
                <div class="search-wrapper">
                    <form class="search-form search-form--nav" id="shop-search-form" action="/html/shop.html" method="GET" role="search">
                        <label for="search-input" class="visually-hidden">Search for products</label>
                        <input
                            type="search"
                            id="search-input"
                            name="q"
                            class="search-form__input"
                            placeholder="Search..."
                            autocomplete="off"
                            maxlength="200"
                        >
                        <!-- Hidden fields to preserve existing filters during search -->
                        <input type="hidden" id="search-preserve-brand" name="brand" value="" disabled>
                        <input type="hidden" id="search-preserve-type" name="type" value="" disabled>
                        <button type="submit" class="search-form__button" aria-label="Search">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                        </button>
                    </form>
                    <div class="search-results" id="search-results" hidden>
                        <ul class="search-results__list" id="search-results-list"></ul>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Brands Mega Dropdown -->
        <div class="brands-mega" id="brands-mega" hidden role="region" aria-label="Browse brands">
            <div class="container">
                <div class="brands-mega__cards"></div>
                <a href="/html/shop.html" class="brands-mega__view-all">
                    View All Brands
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
                </a>
            </div>
        </div>
    </header>

    <!-- ============================================
         MAIN CONTENT - SHOP PAGE (Drill-Down Navigation)
         ============================================ -->
    <main id="main-content" class="site-main">
        <div class="shop-page shop-page--drilldown">
            <div class="container">
                <!-- Breadcrumb Navigation with inline title for products level -->
                <div class="drilldown-header">
                    <div class="drilldown-header__left">
                        <nav class="drilldown-breadcrumb" aria-label="Shop navigation">
                            <ol class="drilldown-breadcrumb__list" id="breadcrumb-list">
                                <li class="drilldown-breadcrumb__item drilldown-breadcrumb__item--current">
                                    <span>Shop</span>
                                </li>
                            </ol>
                        </nav>
                        <span class="drilldown-header__product-type" id="product-type-label" hidden></span>
                    </div>
                    <div class="drilldown-header__right" id="yield-banner" hidden>
                        <strong>Page Yield:</strong>
                        <span id="yield-value"></span>
                    </div>
                </div>

                <!-- Active Filters Display -->
                <div class="active-filters" id="active-filters" hidden>
                    <span class="active-filters__label">Active Filters:</span>
                    <div class="active-filters__list" id="active-filters-list"></div>
                    <button type="button" class="active-filters__clear" id="clear-all-filters">Clear All</button>
                </div>

                <!-- Level Title (hidden on products level) -->
                <h1 class="drilldown-title" id="drilldown-title">Select a Brand</h1>

                <!-- Drill-down Content Area -->
                <section class="drilldown-content">
                    <!-- Level 1: Brands -->
                    <div class="drilldown-level" id="level-brands">
                        <div class="drilldown-grid drilldown-grid--brands" id="brands-grid">
                            <!-- Brand boxes loaded dynamically -->
                        </div>
                    </div>

                    <!-- Level 2: Categories -->
                    <div class="drilldown-level" id="level-categories" hidden>
                        <div class="drilldown-grid drilldown-grid--categories" id="categories-grid">
                            <!-- Category boxes rendered here -->
                        </div>
                    </div>

                    <!-- Level 3: Product Codes -->
                    <div class="drilldown-level" id="level-codes" hidden>
                        <div class="drilldown-grid drilldown-grid--codes" id="codes-grid">
                            <!-- Product code boxes rendered here -->
                        </div>
                    </div>

                    <!-- Level 4: Products -->
                    <div class="drilldown-level" id="level-products" hidden>
                        <!-- For Use In Section -->
                        <div class="product-printers-banner" id="printers-banner" hidden>
                            <strong>For Use In:</strong>
                            <span id="printers-list"></span>
                        </div>

                        <!-- Compatible Products Row (shown first) -->
                        <div class="products-section" id="compatible-section">
                            <h2 class="products-section__title" id="compatible-title">
                                <span class="products-section__badge products-section__badge--compatible">Compatible</span>
                                <span id="compatible-title-text">Compatible Inkjet Cartridges</span>
                            </h2>
                            <div class="products-row" id="compatible-products">
                                <!-- Product cards loaded here -->
                            </div>
                        </div>

                        <!-- Genuine Products Row -->
                        <div class="products-section" id="genuine-section">
                            <h2 class="products-section__title" id="genuine-title">
                                <span class="products-section__badge products-section__badge--genuine">Genuine</span>
                                <span id="genuine-title-text">Original Inkjet Cartridges</span>
                            </h2>
                            <div class="products-row" id="genuine-products">
                                <!-- Product cards loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Loading State - Skeleton Loaders -->
                    <div class="drilldown-loading" id="drilldown-loading" hidden>
                        <!-- Brands Skeleton -->
                        <div class="drilldown-skeleton drilldown-skeleton--brands" id="skeleton-brands" hidden>
                            <div class="drilldown-grid drilldown-grid--brands">
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                                <div class="skeleton skeleton--brand-box"></div>
                            </div>
                        </div>
                        <!-- Categories Skeleton -->
                        <div class="drilldown-skeleton drilldown-skeleton--categories" id="skeleton-categories" hidden>
                            <div class="drilldown-grid drilldown-grid--categories">
                                <div class="skeleton skeleton--category-box"></div>
                                <div class="skeleton skeleton--category-box"></div>
                                <div class="skeleton skeleton--category-box"></div>
                            </div>
                        </div>
                        <!-- Product Codes Skeleton -->
                        <div class="drilldown-skeleton drilldown-skeleton--codes" id="skeleton-codes" hidden>
                            <div class="drilldown-grid drilldown-grid--codes">
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                                <div class="skeleton skeleton--code-box"></div>
                            </div>
                        </div>
                        <!-- Products Skeleton -->
                        <div class="drilldown-skeleton drilldown-skeleton--products" id="skeleton-products" hidden>
                            <div class="products-section">
                                <div class="skeleton skeleton--section-title"></div>
                                <div class="products-row">
                                    <div class="skeleton skeleton--product-card"></div>
                                    <div class="skeleton skeleton--product-card"></div>
                                    <div class="skeleton skeleton--product-card"></div>
                                    <div class="skeleton skeleton--product-card"></div>
                                </div>
                            </div>
                            <div class="products-section">
                                <div class="skeleton skeleton--section-title"></div>
                                <div class="products-row">
                                    <div class="skeleton skeleton--product-card"></div>
                                    <div class="skeleton skeleton--product-card"></div>
                                    <div class="skeleton skeleton--product-card"></div>
                                    <div class="skeleton skeleton--product-card"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Empty State -->
                    <div class="drilldown-empty" id="drilldown-empty" hidden>
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>
                        </svg>
                        <h3>No products found</h3>
                        <p id="empty-message">Try selecting a different category.</p>
                    </div>
                </section>
            </div>
        </div>

        <!-- Need Help Banner -->
        <section class="container">
            <div class="need-help" data-track="support_impression" data-track-location="shop_page">
                <svg class="need-help__icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                <div class="need-help__text">
                    <strong>Need help finding your cartridge?</strong>
                    Call <a href="tel:0800465275" data-track="contact_click" data-track-type="phone" data-track-location="shop_help">0800 INK KART</a> or
                    <a href="mailto:support@inkcartridges.co.nz" data-track="contact_click" data-track-type="email" data-track-location="shop_help">email us</a> â€” we'll match it for you.
                </div>
            </div>
        </section>
    </main>

    <script>
    // ============================================
    // DRILL-DOWN NAVIGATION STATE MACHINE
    // ============================================
    const DrilldownNav = {
        // Current state
        state: {
            level: 'brands',
            brand: null,
            category: null,
            code: null,
            printer: null,      // For printer-based product lookup
            printerName: null,  // Display name for the printer
            type: null          // 'genuine' or 'compatible' filter
        },

        // Navigation version to prevent race conditions
        // Incremented on each navigation, checked before rendering
        navigationVersion: 0,

        // Cached data
        cache: {
            brands: null,
            products: {}
        },

        // Static categories - mapped to backend API values
        // Note: 'consumable' uses 'toner' API category since drums/supplies are toner-related
        // Client-side filtering by product_type separates toner cartridges from drums/supplies
        categories: [
            { id: 'ink', name: 'Ink Cartridges', icon: 'droplet', apiCategory: 'ink' },
            { id: 'toner', name: 'Toner Cartridges', icon: 'box', apiCategory: 'toner' },
            { id: 'consumable', name: 'Drums & Supplies', icon: 'disc', apiCategory: 'toner' }
        ],

        // Compatible products now have "Compatible" prefix in their name
        compatiblePrefix: 'compatible',

        // Brand display info with local logos
        brandInfo: {
            brother: { name: 'Brother', logo: '/assets/brands/brother.png' },
            canon: { name: 'Canon', logo: '/assets/brands/canon.png' },
            epson: { name: 'Epson', logo: '/assets/brands/epson.png' },
            hp: { name: 'HP', logo: '/assets/brands/hp.png' },
            samsung: { name: 'Samsung', logo: '/assets/brands/samsung.svg' },
            lexmark: { name: 'Lexmark', logo: '/assets/brands/lexmark.png' },
            oki: { name: 'OKI', logo: '/assets/brands/oki.svg' },
            'fuji-xerox': { name: 'Fuji Xerox', logo: '/assets/brands/fuji-xerox.png' },
            kyocera: { name: 'Kyocera', logo: '/assets/brands/kyocera.svg' }
        },

        // DOM Elements
        elements: {
            breadcrumbList: document.getElementById('breadcrumb-list'),
            title: document.getElementById('drilldown-title'),
            productTypeLabel: document.getElementById('product-type-label'),
            levelBrands: document.getElementById('level-brands'),
            levelCategories: document.getElementById('level-categories'),
            levelCodes: document.getElementById('level-codes'),
            levelProducts: document.getElementById('level-products'),
            brandsGrid: document.getElementById('brands-grid'),
            categoriesGrid: document.getElementById('categories-grid'),
            codesGrid: document.getElementById('codes-grid'),
            genuineProducts: document.getElementById('genuine-products'),
            compatibleProducts: document.getElementById('compatible-products'),
            genuineSection: document.getElementById('genuine-section'),
            compatibleSection: document.getElementById('compatible-section'),
            compatibleTitleText: document.getElementById('compatible-title-text'),
            genuineTitleText: document.getElementById('genuine-title-text'),
            printersBanner: document.getElementById('printers-banner'),
            printersList: document.getElementById('printers-list'),
            yieldBanner: document.getElementById('yield-banner'),
            yieldValue: document.getElementById('yield-value'),
            loading: document.getElementById('drilldown-loading'),
            empty: document.getElementById('drilldown-empty'),
            emptyMessage: document.getElementById('empty-message'),
            // Skeleton elements
            skeletonBrands: document.getElementById('skeleton-brands'),
            skeletonCategories: document.getElementById('skeleton-categories'),
            skeletonCodes: document.getElementById('skeleton-codes'),
            skeletonProducts: document.getElementById('skeleton-products')
        },

        // =========================================
        // INITIALIZATION
        // =========================================
        async init() {
            // Parse URL params to restore state
            this.parseURLState();

            // Load initial level based on state
            this.navigationVersion++;
            await this.loadCurrentLevel(this.navigationVersion);

            // Render active filter indicators
            this.renderActiveFilters();

            // Set up browser navigation
            window.addEventListener('popstate', (e) => {
                if (e.state) {
                    this.state = e.state;
                } else {
                    this.parseURLState();
                }
                this.navigationVersion++;
                this.loadCurrentLevel(this.navigationVersion);
                this.renderActiveFilters();
            });

            // Set up search form to preserve current filters
            this.setupSearchForm();
        },

        // Set up search form to preserve filters when searching
        setupSearchForm() {
            const searchForm = document.getElementById('shop-search-form');
            if (!searchForm) return;

            const brandField = document.getElementById('search-preserve-brand');
            const typeField = document.getElementById('search-preserve-type');

            searchForm.addEventListener('submit', (e) => {
                // Enable and populate hidden fields with current filter state
                if (this.state.brand && brandField) {
                    brandField.value = this.state.brand;
                    brandField.disabled = false;
                }
                if (this.state.type && typeField) {
                    typeField.value = this.state.type;
                    typeField.disabled = false;
                }
                // Form will submit naturally with preserved filters
            });
        },

        // Clear all filters and reset to initial state
        clearAllFilters() {
            // Clear cache to ensure fresh data
            this.cache.products = {};

            // Reset state
            this.state = {
                level: 'brands',
                brand: null,
                category: null,
                code: null,
                printer: null,
                printerName: null,
                printerModel: null,
                printerModelDisplay: null,
                search: null,
                type: null
            };

            // Clear URL
            history.pushState(this.state, '', window.location.pathname);

            // Reload brands level
            this.navigationVersion++;
            this.loadCurrentLevel(this.navigationVersion);
        },

        // Remove a specific filter
        removeFilter(filterType) {
            switch (filterType) {
                case 'type':
                    this.state.type = null;
                    break;
                case 'search':
                    this.state.search = null;
                    // If we were in search-results, go back to brands or current nav level
                    if (this.state.level === 'search-results') {
                        if (this.state.code) {
                            this.state.level = 'products';
                        } else if (this.state.category) {
                            this.state.level = 'codes';
                        } else if (this.state.brand) {
                            this.state.level = 'categories';
                        } else {
                            this.state.level = 'brands';
                        }
                    }
                    break;
                case 'brand':
                    this.state.brand = null;
                    this.state.category = null;
                    this.state.code = null;
                    this.state.level = 'brands';
                    break;
                case 'category':
                    this.state.category = null;
                    this.state.code = null;
                    this.state.level = 'categories';
                    break;
            }

            // Invalidate cache
            this.cache.products = {};

            this.updateURL();
            this.navigationVersion++;
            this.loadCurrentLevel(this.navigationVersion);
            this.renderActiveFilters();
        },

        // Render active filter chips
        renderActiveFilters() {
            const container = document.getElementById('active-filters');
            const list = document.getElementById('active-filters-list');
            const clearBtn = document.getElementById('clear-all-filters');

            if (!container || !list) return;

            list.innerHTML = '';
            let hasFilters = false;

            // Type filter (genuine/compatible)
            if (this.state.type) {
                hasFilters = true;
                const chip = document.createElement('button');
                chip.className = 'active-filters__chip';
                chip.innerHTML = `
                    ${this.state.type === 'genuine' ? 'Genuine Only' : 'Compatible Only'}
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                `;
                chip.addEventListener('click', () => this.removeFilter('type'));
                list.appendChild(chip);
            }

            // Search filter
            if (this.state.search && this.state.level === 'search-results') {
                hasFilters = true;
                const chip = document.createElement('button');
                chip.className = 'active-filters__chip';
                chip.innerHTML = `
                    Search: "${this.state.search}"
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                `;
                chip.addEventListener('click', () => this.removeFilter('search'));
                list.appendChild(chip);
            }

            // Show/hide container
            container.hidden = !hasFilters;

            // Set up clear all button
            if (clearBtn && hasFilters) {
                clearBtn.onclick = () => this.clearAllFilters();
            }
        },

        parseURLState() {
            const params = new URLSearchParams(window.location.search);
            this.state.brand = params.get('brand');
            this.state.category = params.get('category');
            this.state.code = params.get('code');
            this.state.printer = params.get('printer');
            this.state.printerModel = params.get('printer_model');
            this.state.printerBrand = params.get('printer_brand'); // Brand of printer (for display, not filtering)
            this.state.search = params.get('search') || params.get('q'); // Support both 'search' and 'q' params
            this.state.type = params.get('type'); // Support 'type' param for genuine/compatible filtering

            // Determine level from state - search takes priority when combined with filters
            if (this.state.search) {
                // Text search mode (may be combined with brand/type filters)
                this.state.level = 'search-results';
            } else if (this.state.printerModel) {
                // Filter products by printer model (from compatible_printers field)
                this.state.level = 'printer-model-products';
            } else if (this.state.printer) {
                // Special case: loading products for a specific printer
                this.state.level = 'printer-products';
            } else if (this.state.code) {
                this.state.level = 'products';
            } else if (this.state.category) {
                this.state.level = 'codes';
            } else if (this.state.brand) {
                this.state.level = 'categories';
            } else {
                this.state.level = 'brands';
            }

        },

        updateURL() {
            const params = new URLSearchParams();
            if (this.state.brand) params.set('brand', this.state.brand);
            if (this.state.category) params.set('category', this.state.category);
            if (this.state.code) params.set('code', this.state.code);
            if (this.state.type) params.set('type', this.state.type);
            if (this.state.search) params.set('q', this.state.search);

            const newURL = params.toString()
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;

            history.pushState({ ...this.state }, '', newURL);
        },

        // =========================================
        // NAVIGATION METHODS
        // =========================================
        async navigateTo(level, data = {}) {
            // Increment navigation version to cancel any pending renders
            this.navigationVersion++;
            const thisNavVersion = this.navigationVersion;

            // Preserve type filter across navigation
            const currentType = this.state.type;

            // Update state
            switch (level) {
                case 'brands':
                    this.state = { level: 'brands', brand: null, category: null, code: null, type: currentType };
                    break;
                case 'categories':
                    this.state = { level: 'categories', brand: data.brand, category: null, code: null, type: currentType };
                    break;
                case 'codes':
                    this.state = { level: 'codes', brand: this.state.brand, category: data.category, code: null, type: currentType };
                    break;
                case 'products':
                    this.state = { level: 'products', brand: this.state.brand, category: this.state.category, code: data.code, type: currentType };
                    break;
            }

            this.updateURL();
            window.scrollTo(0, 0);
            await this.loadCurrentLevel(thisNavVersion);
        },

        async loadCurrentLevel(navVersion) {
            // Use current version if not provided (for direct calls)
            const expectedVersion = navVersion ?? this.navigationVersion;

            // Hide all levels first
            this.hideAllLevels();

            switch (this.state.level) {
                case 'brands':
                    await this.loadBrands(expectedVersion);
                    break;
                case 'categories':
                    await this.loadCategories(expectedVersion);
                    break;
                case 'codes':
                    await this.loadProductCodes(expectedVersion);
                    break;
                case 'products':
                    await this.loadProducts(expectedVersion);
                    break;
                case 'printer-products':
                    await this.loadPrinterProducts(expectedVersion);
                    break;
                case 'printer-model-products':
                    await this.loadPrinterModelProducts(expectedVersion);
                    break;
                case 'search-results':
                    await this.loadSearchResults(expectedVersion);
                    break;
            }

            // Only update UI if this is still the current navigation
            if (this.navigationVersion === expectedVersion) {
                this.updateBreadcrumb();
                this.updateTitle();
            }
        },

        hideAllLevels() {
            this.elements.levelBrands.hidden = true;
            this.elements.levelCategories.hidden = true;
            this.elements.levelCodes.hidden = true;
            this.elements.levelProducts.hidden = true;
            this.elements.empty.hidden = true;
        },

        showLoading(show, level = null) {
            this.elements.loading.hidden = !show;

            // Hide all skeletons first
            if (this.elements.skeletonBrands) this.elements.skeletonBrands.hidden = true;
            if (this.elements.skeletonCategories) this.elements.skeletonCategories.hidden = true;
            if (this.elements.skeletonCodes) this.elements.skeletonCodes.hidden = true;
            if (this.elements.skeletonProducts) this.elements.skeletonProducts.hidden = true;

            // Show appropriate skeleton based on level
            if (show) {
                const currentLevel = level || this.state.level;
                switch (currentLevel) {
                    case 'brands':
                        if (this.elements.skeletonBrands) this.elements.skeletonBrands.hidden = false;
                        break;
                    case 'categories':
                        if (this.elements.skeletonCategories) this.elements.skeletonCategories.hidden = false;
                        break;
                    case 'codes':
                        if (this.elements.skeletonCodes) this.elements.skeletonCodes.hidden = false;
                        break;
                    case 'products':
                    case 'printer-products':
                    case 'printer-model-products':
                    case 'search-results':
                        if (this.elements.skeletonProducts) this.elements.skeletonProducts.hidden = false;
                        break;
                }
            }
        },

        showEmpty(message) {
            this.elements.emptyMessage.textContent = message;
            this.elements.empty.hidden = false;
        },

        // =========================================
        // LEVEL LOADERS
        // =========================================
        async loadBrands(navVersion) {
            this.showLoading(true);

            try {
                // Use cached brands or fetch from API
                if (!this.cache.brands) {
                    const response = await API.getBrands();
                    // Check if navigation changed during fetch
                    if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                    if (response.success && response.data) {
                        this.cache.brands = response.data;
                    } else {
                        // Fallback to static brands
                        this.cache.brands = Object.keys(this.brandInfo).map(id => ({
                            id,
                            name: this.brandInfo[id].name,
                            slug: id
                        }));
                    }
                }

                // Check if navigation changed before rendering
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                this.renderBrands(this.cache.brands);
                this.elements.levelBrands.hidden = false;
            } catch (error) {
                console.error('Failed to load brands:', error);
                // Check if navigation changed
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                // Fallback to static brands
                this.cache.brands = Object.keys(this.brandInfo).map(id => ({
                    id,
                    name: this.brandInfo[id].name,
                    slug: id
                }));
                this.renderBrands(this.cache.brands);
                this.elements.levelBrands.hidden = false;
            }

            this.showLoading(false);
        },

        renderBrands(brands) {
            const grid = this.elements.brandsGrid;
            grid.innerHTML = '';

            // Render in preferred order
            const orderedBrands = ['brother', 'canon', 'epson', 'hp', 'samsung', 'lexmark', 'oki', 'fuji-xerox', 'kyocera'];

            orderedBrands.forEach(brandId => {
                const brand = brands.find(b => b.slug === brandId || b.id === brandId);
                const info = this.brandInfo[brandId];

                if (info) {
                    const box = document.createElement('button');
                    box.className = 'drilldown-box drilldown-box--brand';
                    box.dataset.brand = brandId;
                    box.innerHTML = `
                        <img src="${info.logo}" alt="${info.name}" class="drilldown-box__logo drilldown-box__logo--${brandId}">
                    `;
                    box.addEventListener('click', () => this.navigateTo('categories', { brand: brandId }));
                    grid.appendChild(box);
                }
            });
        },

        async loadCategories(navVersion) {
            const grid = this.elements.categoriesGrid;
            grid.innerHTML = '';
            this.showLoading(true);

            const icons = {
                droplet: '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>',
                box: '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>',
                disc: '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg>',
                package: '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><line x1="16.5" y1="9.4" x2="7.5" y2="4.21"/><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>'
            };

            // Check cache for category counts
            const cacheKey = `${this.state.brand}-category-counts-v2`;
            let categoryCounts = this.cache.products[cacheKey];

            if (!categoryCounts) {
                // Helper to fetch ALL pages of products
                const fetchAllProducts = async (params) => {
                    let allProducts = [];
                    let page = 1;
                    let hasMore = true;
                    while (hasMore) {
                        const response = await API.getProducts({ ...params, page, limit: 100 });
                        // Check if navigation changed during fetch
                        if (navVersion !== undefined && this.navigationVersion !== navVersion) return null;

                        if (response.success && response.data?.products) {
                            allProducts = allProducts.concat(response.data.products);
                            const pagination = response.data.pagination;
                            hasMore = pagination && page < pagination.total_pages;
                            page++;
                        } else {
                            hasMore = false;
                        }
                    }
                    return allProducts;
                };

                // Helper to count products by product_type
                const countByProductType = (products, categoryId) => {
                    return products.filter(p => {
                        const productType = (p.product_type || '').toLowerCase();
                        if (categoryId === 'ink') {
                            return productType === 'ink_cartridge' || productType === 'ink_bottle';
                        } else if (categoryId === 'toner') {
                            return productType === 'toner_cartridge';
                        } else if (categoryId === 'consumable') {
                            return productType === 'drum_unit' ||
                                   productType === 'waste_toner' ||
                                   productType === 'belt_unit' ||
                                   productType === 'fuser_kit' ||
                                   productType === 'maintenance_kit';
                        }
                        return true;
                    }).length;
                };

                try {
                    categoryCounts = {};

                    // Fetch ink products and count
                    const inkProducts = await fetchAllProducts({
                        brand: this.state.brand,
                        category: 'ink'
                    });
                    // Check if navigation changed or fetch was aborted
                    if (inkProducts === null) return;
                    categoryCounts['ink'] = countByProductType(inkProducts, 'ink');

                    // Fetch toner products (includes both toner cartridges and drums/supplies)
                    const tonerProducts = await fetchAllProducts({
                        brand: this.state.brand,
                        category: 'toner'
                    });
                    // Check if navigation changed or fetch was aborted
                    if (tonerProducts === null) return;
                    // Count toner cartridges
                    categoryCounts['toner'] = countByProductType(tonerProducts, 'toner');
                    // Count drums & supplies
                    categoryCounts['consumable'] = countByProductType(tonerProducts, 'consumable');

                    this.cache.products[cacheKey] = categoryCounts;
                } catch (error) {
                    console.error('Error fetching category counts:', error);
                    // Check if navigation changed
                    if (navVersion !== undefined && this.navigationVersion !== navVersion) return;
                    // Fallback: show all categories
                    categoryCounts = {};
                    this.categories.forEach(cat => categoryCounts[cat.id] = 1);
                }
            }

            // Check if navigation changed before rendering
            if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

            // Filter categories to only those with products
            const availableCategories = this.categories.filter(cat => categoryCounts[cat.id] > 0);

            this.showLoading(false);

            if (availableCategories.length === 0) {
                this.showEmpty('No products available for this brand.');
                return;
            }

            availableCategories.forEach(cat => {
                const box = document.createElement('button');
                box.className = 'drilldown-box drilldown-box--category';
                box.dataset.category = cat.id;
                const count = categoryCounts[cat.id];
                box.innerHTML = `
                    <span class="drilldown-box__icon">${icons[cat.icon]}</span>
                    <span class="drilldown-box__name">${cat.name}</span>
                    <span class="drilldown-box__count">${count} product${count !== 1 ? 's' : ''}</span>
                `;
                box.addEventListener('click', () => this.navigateTo('codes', { category: cat.id }));
                grid.appendChild(box);
            });

            this.elements.levelCategories.hidden = false;
        },

        async loadProductCodes(navVersion) {
            this.showLoading(true);

            try {
                // Get the API category value
                const categoryConfig = this.categories.find(c => c.id === this.state.category);
                const apiCategory = categoryConfig?.apiCategory || this.state.category;
                const brandName = this.brandInfo[this.state.brand]?.name || this.state.brand;

                // Include type filter in cache key to prevent stale results when switching genuine/compatible
                // Use category ID (not apiCategory) since toner and consumable both use 'toner' API category
                // v4: Fixed strict brand filtering to prevent cross-brand products
                const typeKey = this.state.type || 'all';
                const categoryId = this.state.category;
                const cacheKey = `${this.state.brand}-${categoryId}-${typeKey}-codes-v4`;
                const codesCacheKey = `${cacheKey}-final`;

                // Check if we have cached codes with counts already
                if (this.cache.products[codesCacheKey]) {
                    const cachedCodes = this.cache.products[codesCacheKey];
                    if (cachedCodes.length === 0) {
                        this.showEmpty('No products found for this category.');
                    } else {
                        this.renderProductCodes(cachedCodes);
                        this.elements.levelCodes.hidden = false;
                    }
                    this.showLoading(false);
                    return;
                }

                if (!this.cache.products[cacheKey]) {
                    let brandProducts = [];
                    let searchProducts = [];

                    // Helper function to filter products by brand - STRICT matching
                    const brandNameLower = brandName.toLowerCase();
                    const brandNameNoSpace = brandNameLower.replace(/[\s-]/g, '');
                    const brandSlug = this.state.brand.toLowerCase();
                    const filterByBrand = (products) => {
                        return products.filter(p => {
                            // Primary check: product's brand field must match
                            const productBrandName = (p.brand?.name || '').toLowerCase();
                            const productBrandSlug = (p.brand?.slug || '').toLowerCase();

                            // Exact match on brand field (most reliable)
                            if (productBrandName === brandNameLower ||
                                productBrandSlug === brandSlug ||
                                productBrandName.replace(/[\s-]/g, '') === brandNameNoSpace) {
                                return true;
                            }

                            // Fallback: check if product name STARTS with brand name
                            // This catches "Epson T123" but not "Compatible for Epson"
                            const name = (p.name || '').toLowerCase();
                            const nameWithoutPrefix = name.replace(/^(compatible|genuine)\s+/i, '');
                            if (nameWithoutPrefix.startsWith(brandNameLower) ||
                                nameWithoutPrefix.startsWith(brandNameNoSpace)) {
                                return true;
                            }

                            return false;
                        });
                    };

                    // Helper to fetch ALL pages of products
                    const fetchAllProducts = async (params) => {
                        let allProducts = [];
                        let page = 1;
                        let hasMore = true;

                        while (hasMore) {
                            const response = await API.getProducts({ ...params, page, limit: 100 });
                            if (response.success && response.data?.products) {
                                allProducts = allProducts.concat(response.data.products);
                                const pagination = response.data.pagination;
                                hasMore = pagination && page < pagination.total_pages;
                                page++;
                            } else {
                                hasMore = false;
                            }
                        }
                        return allProducts;
                    };

                    // Try to fetch products with brand filter (may fail for new brands not in API)
                    // Also apply source filter if type is specified (genuine/compatible)
                    const apiParams = {
                        brand: this.state.brand,
                        category: apiCategory
                    };
                    // Map URL 'type' parameter to API 'source' parameter
                    if (this.state.type === 'genuine' || this.state.type === 'compatible') {
                        apiParams.source = this.state.type;
                    }

                    try {
                        let rawBrandProducts = await fetchAllProducts(apiParams);

                        // If no results with slug, try with brand name
                        if (rawBrandProducts.length === 0) {
                            apiParams.brand = brandName;
                            rawBrandProducts = await fetchAllProducts(apiParams);
                        }

                        // Trust the API's brand filter - don't filter again client-side
                        // This ensures all products returned by the API are included
                        brandProducts = rawBrandProducts;
                    } catch (brandError) {
                        // Brand filter not supported for this brand - will rely on search
                    }

                    // Fetch products by searching brand name (primary method for new brands)
                    try {
                        searchProducts = await fetchAllProducts({ search: brandName });

                        // If no results, try searching with category added
                        if (searchProducts.length === 0) {
                            searchProducts = await fetchAllProducts({ search: `${brandName} ${apiCategory}` });
                        }
                    } catch (searchError) {
                        // Search failed - continue with any results we have
                    }

                    // For Fuji Xerox, also search variations
                    if (this.state.brand === 'fuji-xerox') {
                        const variations = ['Fuji-Xerox', 'FujiXerox', 'Xerox'];
                        for (const variant of variations) {
                            try {
                                const variantProducts = await fetchAllProducts({ search: variant });
                                searchProducts = [...searchProducts, ...variantProducts];
                            } catch (e) {
                                // Ignore variant search errors
                            }
                        }
                    }

                    // Filter search results by category using category ID and product_type
                    // categoryId is already declared above
                    let compatibleProducts = searchProducts.filter(p => {
                        const productType = (p.product_type || '').toLowerCase();
                        if (categoryId === 'ink') {
                            return productType === 'ink_cartridge' || productType === 'ink_bottle';
                        } else if (categoryId === 'toner') {
                            return productType === 'toner_cartridge';
                        } else if (categoryId === 'consumable') {
                            return productType === 'drum_unit' ||
                                   productType === 'waste_toner' ||
                                   productType === 'belt_unit' ||
                                   productType === 'fuser_kit' ||
                                   productType === 'maintenance_kit';
                        }
                        return true;
                    });

                    // Filter to only include products from this brand
                    compatibleProducts = filterByBrand(compatibleProducts);

                    // Merge and dedupe by product id
                    const seenIds = new Set();
                    const allProducts = [];
                    for (const p of [...brandProducts, ...compatibleProducts]) {
                        if (!seenIds.has(p.id)) {
                            seenIds.add(p.id);
                            allProducts.push(p);
                        }
                    }

                    this.cache.products[cacheKey] = allProducts;
                }

                let allProducts = this.cache.products[cacheKey];

                // Brand filtering is already done:
                // - API brand filter applied when fetching
                // - filterByBrand applied to search results
                // No need to filter again here - trust the cached products

                // Apply category filter to cached products using category ID (not apiCategory)
                // This is important because 'consumable' (drums) uses 'toner' API category
                // categoryId is already declared above
                allProducts = allProducts.filter(p => {
                    const productType = (p.product_type || '').toLowerCase();

                    if (categoryId === 'ink') {
                        // Only ink cartridges and ink bottles
                        return productType === 'ink_cartridge' || productType === 'ink_bottle';
                    } else if (categoryId === 'toner') {
                        // Only toner cartridges (not drums, waste toner, etc.)
                        return productType === 'toner_cartridge';
                    } else if (categoryId === 'consumable') {
                        // Drums and supplies: drum units, waste toner, belts, fusers (NOT toner cartridges)
                        return productType === 'drum_unit' ||
                               productType === 'waste_toner' ||
                               productType === 'belt_unit' ||
                               productType === 'fuser_kit' ||
                               productType === 'maintenance_kit';
                    }
                    return true;
                });

                // Check if navigation changed before rendering
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                // Extract codes from filtered products - this gives us counts directly
                const codes = this.extractProductCodes(allProducts);

                // Cache the final codes with counts
                this.cache.products[codesCacheKey] = codes;

                if (codes.length === 0) {
                    this.showEmpty('No products found for this category.');
                } else {
                    this.renderProductCodes(codes);
                    this.elements.levelCodes.hidden = false;
                }
            } catch (error) {
                console.error('Failed to load product codes:', error);
                // Check if navigation changed
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;
                this.showEmpty('Failed to load products. Please try again.');
            }

            this.showLoading(false);
        },

        extractProductCodes(products) {
            if (!products || products.length === 0) return [];

            const codeMap = new Map();
            const brand = this.state.brand.toLowerCase();

            // Brand-specific regex patterns for extracting product codes
            // These patterns match the manufacturer part number format
            const patterns = {
                // Brother: LC (ink), TN (toner), DR (drum), TZe/DK (labels), PC (fax), BU/WT (belt/waste), BT (bottles), HC, PRINK
                brother: /\b(LC[-]?\d{2,5}(?:X{1,3}L)?[A-Z]{0,3}|TN[-]?\d{3,4}(?:X{1,3}L)?[A-Z]{0,4}|DR[-]?\d{3,4}[A-Z]{0,2}|TZE?[-]?[A-Z]{0,3}\d{3,4}|DK[-]?\d{4,5}|PC[-]?\d{3}|BU[-]?\d{3}[A-Z]{0,2}|WT[-]?\d{3}[A-Z]{0,2}|BT[-]?\d{3,4}[A-Z]{0,3}|HC\d{2,4}[A-Z]{0,3}|PRINK[A-Z]?)\b/gi,
                // Canon: PG/CL/PGI/CLI/BCI (ink), GI (bottles), PFI (pro ink), CART (toner), FX (fax), EP, NPG, TG/GPR, T, LK, NB, MC, WT
                canon: /\b((?:PG|CL|PGI|CLI|BCI|GI|PFI)[-]?\d{1,4}(?:X{1,3}L)?[A-Z]{0,2}|CART[-]?\d{3}[A-Z]{0,4}(?:II)?|EP[-]?\d{2,3}|NPG[-]?\d{2,3}|TG[-]?\d{2,3}|GPR[-]?\d{2,3}|FX[-]?\d{1,2}|T\d{2}[A-Z]?|LK[-]?\d{2,3}|NB[-]?CP\d[A-Z]*|MC[-]?G\d{2}|WT[-]?[A-Z]\d|\d[A-Z]{2}\d{2}[A-Z])\b/gi,
                // Epson: T series, C13T (OEM), ERC (ribbon), N-suffix codes (73N, 81N), numeric codes
                epson: /\b(T\d{2,4}(?:X{1,3}L)?[A-Z]?|C13T\d+|ERC[-]?\d{2,3}|\d{2,3}N|\d{2,5}(?:XL)?)\b/gi,
                // HP: numeric series, CF/CE/CC/W/Q/C series, alphanumeric large format codes
                hp: /\b(\d{2,3}(?:X{1,3}L)?[A-Z]?|C[A-Z]?\d{3,4}[A-Z]?|CC\d{3}[A-Z]?|CF\d{3}[A-Z]?|CE\d{3}[A-Z]?|W\d{4}[A-Z]?|Q\d{4}[A-Z]?|[A-Z]\d[A-Z]\d{2}[A-Z])\b/gi,
                // Samsung: MLT-D/R/W (toner/drum/waste), CLT-C/K/M/Y/W/R/P (color toner/waste/drum/pack)
                samsung: /\b((?:MLT[-]?[DRW]|CLT[-]?[CKMYWRP])\d{3}[A-Z]?|(?:ML|CLP|CLX|SCX|SL[-]?[MC])\d{3,5})\b/gi,
                // Lexmark: 7-char alphanumeric codes (20N3HC0, C540H1CG, 50F3000, 78C6UCE, etc.)
                lexmark: /\b(\d{2}[A-Z][A-Z0-9]{4,5}|[CBXETW]\d{2,4}[A-Z0-9]{2,5})\b/gi,
                // OKI: B/C/MC model codes (with optional DN suffix)
                oki: /\b([BCM]{1,2}\d{3,4}(?:DN)?)\b/gi,
                // Fuji Xerox: CT, CWAA, Xerox numeric (106R, 108R), E/EC/EL prefix codes
                'fuji-xerox': /\b(CT\d{6}|CWAA\d{4}|\d{3}R\d{5}|E[CL]?\d{5,6})\b/gi,
                // Kyocera: TK (toner), DK (drum), WT (waste) â€” allow color suffix on TK
                kyocera: /\b(TK[-]?\d{3,4}[A-Z]?|DK[-]?\d{3,4}|WT[-]?\d{3,4})\b/gi
            };

            // Brand prefixes used in SKUs (internal codes, not manufacturer codes)
            const brandPrefixes = {
                brother: 'B',
                canon: 'C',
                epson: 'E',
                hp: 'H',
                samsung: 'S',
                lexmark: 'L',
                oki: 'O',
                'fuji-xerox': 'F',
                kyocera: 'K'
            };

            products.forEach(product => {
                const name = product.name || '';
                const sku = product.sku || '';
                const mpn = product.manufacturer_part_number || '';
                const pattern = patterns[brand];

                // Collect ALL codes found in this product
                const foundCodes = new Set();

                // ALWAYS extract ALL codes from product name first
                // This is critical for products compatible with multiple series (e.g., LC77 LC73 LC40)
                if (pattern) {
                    const nameMatches = name.matchAll(pattern);
                    for (const match of nameMatches) {
                        const code = this.normalizeCode(match[0], brand);
                        if (code && code.length >= 2) {
                            foundCodes.add(code);
                        }
                    }
                }

                // Also check manufacturer_part_number
                if (mpn) {
                    const normalizedMpn = this.normalizeCode(mpn, brand);
                    if (normalizedMpn && normalizedMpn.length >= 2) {
                        foundCodes.add(normalizedMpn);
                    }
                }

                // Also check SKU for additional codes
                if (pattern && sku) {
                    pattern.lastIndex = 0;
                    const skuMatches = sku.matchAll(pattern);
                    for (const match of skuMatches) {
                        const code = this.normalizeCode(match[0], brand);
                        if (code && code.length >= 2) {
                            foundCodes.add(code);
                        }
                    }
                }

                // Fallback if no codes found - try generic pattern on name
                if (foundCodes.size === 0) {
                    const fallbackPattern = /\b[A-Z]{1,3}[-]?\d{1,4}(?:XL)?[A-Z]{0,3}\b/gi;
                    const fallbackMatches = name.matchAll(fallbackPattern);
                    for (const match of fallbackMatches) {
                        const code = this.normalizeCode(match[0], brand);
                        if (code && code.length >= 2) {
                            foundCodes.add(code);
                        }
                    }
                }

                // PRIORITY 5: Infer manufacturer code from SKU
                // SKUs like "B431B" should become "LC431" for Brother ink cartridges
                if (foundCodes.size === 0 && sku) {
                    let skuCode = sku.toUpperCase();
                    const prefix = brandPrefixes[brand];

                    // Strip the brand prefix from SKU (e.g., B for Brother)
                    if (prefix && skuCode.startsWith(prefix)) {
                        skuCode = skuCode.substring(1);
                    }

                    // Strip "IB" prefix if present (internal code)
                    if (skuCode.startsWith('IB')) {
                        skuCode = skuCode.substring(2);
                    }

                    // Infer the manufacturer code prefix based on brand and product type
                    const productType = (product.product_type || '').toLowerCase();
                    const category = this.state.category || '';

                    // For Brother products, add the appropriate series prefix
                    if (brand === 'brother') {
                        // Check if code already has a known prefix
                        if (!skuCode.startsWith('LC') && !skuCode.startsWith('TN') && !skuCode.startsWith('DR')) {
                            if (productType === 'ink_cartridge' || productType === 'ink_bottle' || category === 'ink') {
                                skuCode = 'LC' + skuCode;
                            } else if (productType === 'toner_cartridge' || category === 'toner') {
                                skuCode = 'TN' + skuCode;
                            } else if (productType === 'drum_unit' || category === 'consumable') {
                                skuCode = 'DR' + skuCode;
                            }
                        }
                    }
                    // For Canon products
                    else if (brand === 'canon') {
                        if (!skuCode.startsWith('PG') && !skuCode.startsWith('CL') &&
                            !skuCode.startsWith('PGI') && !skuCode.startsWith('CLI') &&
                            !skuCode.startsWith('BCI') && !skuCode.startsWith('GI') &&
                            !skuCode.startsWith('PFI') && !skuCode.startsWith('CART') &&
                            !skuCode.startsWith('FX')) {
                            // Canon ink cartridges have diverse prefixes
                            // Without knowing the series, we can't reliably add prefix
                        }
                    }
                    // For Epson products
                    else if (brand === 'epson') {
                        if (!skuCode.startsWith('T') && !skuCode.startsWith('C13')) {
                            if (productType === 'ink_cartridge' || productType === 'ink_bottle' || category === 'ink') {
                                // Epson codes typically start with T
                                if (/^\d/.test(skuCode)) {
                                    skuCode = 'T' + skuCode;
                                }
                            }
                        }
                    }
                    // For OKI products: SKU like O831Y â†’ strip O prefix + color suffix â†’ 831 â†’ C831
                    else if (brand === 'oki') {
                        const okiModelMatch = skuCode.match(/^(\d{3,4})/);
                        if (okiModelMatch) {
                            skuCode = 'C' + okiModelMatch[1];
                        }
                    }

                    // Normalize the code to strip color suffixes and get base code
                    skuCode = this.normalizeCode(skuCode, brand);
                    if (skuCode) {
                        foundCodes.add(skuCode);
                    }
                }

                // PRIORITY 6: Last resort - use product name
                if (foundCodes.size === 0) {
                    const nameCode = name.replace(/^(Compatible|Genuine)\s*/i, '')
                                        .split(/\s+/)
                                        .slice(0, 3)
                                        .join('-')
                                        .toUpperCase()
                                        .substring(0, 20);
                    if (nameCode) {
                        foundCodes.add(nameCode);
                    }
                }

                // For HP: prefer numeric series codes over OEM part numbers
                // Product names like "HP 62 Ink Cartridge Black (C2P04AA)" contain both
                // the series (62) and OEM code (C2P04) â€” only keep the numeric series
                if (brand === 'hp' && foundCodes.size > 1) {
                    const numericCodes = new Set();
                    const otherCodes = new Set();
                    foundCodes.forEach(code => {
                        if (/^\d{2,3}$/.test(code)) {
                            numericCodes.add(code);
                        } else {
                            otherCodes.add(code);
                        }
                    });
                    if (numericCodes.size > 0 && otherCodes.size > 0) {
                        foundCodes.clear();
                        numericCodes.forEach(code => foundCodes.add(code));
                    }
                }

                // Add product to EACH code it matches
                foundCodes.forEach(code => {
                    if (!codeMap.has(code)) {
                        codeMap.set(code, { code, count: 0, products: [] });
                    }
                    const entry = codeMap.get(code);
                    entry.count++;
                    entry.products.push(product);
                });
            });

            // Sort codes alphabetically/numerically
            return Array.from(codeMap.values()).sort((a, b) => {
                // Extract numeric portion for comparison
                const numA = parseInt(a.code.replace(/\D/g, '')) || 0;
                const numB = parseInt(b.code.replace(/\D/g, '')) || 0;
                if (numA !== numB) return numA - numB;
                return a.code.localeCompare(b.code);
            });
        },

        normalizeCode(code, brand = null) {
            // Remove hyphens and spaces, uppercase
            let normalized = code.replace(/[-\s]/g, '').toUpperCase();

            // Strip internal prefixes (IB = Ink Brother, etc.)
            if (normalized.startsWith('IB')) {
                normalized = normalized.substring(2);
            }

            // For Brother: LC/TN/DR/TZe/DK/PC/BU/WT/BT/HC/PRINK
            if (brand === 'brother') {
                // LC (ink) â€” strip color suffix, support XXL
                const lcMatch = normalized.match(/^(LC\d{2,5}(?:X{1,3}L)?)/i);
                if (lcMatch) return lcMatch[1];
                // TN (toner) â€” strip color suffix, support XXL
                const tnMatch = normalized.match(/^(TN\d{3,4}(?:X{1,3}L)?)/i);
                if (tnMatch) return tnMatch[1];
                // DR (drum) â€” strip CL/color suffix
                const drMatch = normalized.match(/^(DR\d{3,4})/i);
                if (drMatch) return drMatch[1];
                // TZe label tapes (TZe231, TZEFX431, etc.) â€” normalize to TZE + digits
                const tzeMatch = normalized.match(/^TZE?[A-Z]{0,3}(\d{3,4})/i);
                if (tzeMatch) return 'TZE' + tzeMatch[1];
                // DK label rolls
                const dkMatch = normalized.match(/^(DK\d{4,5})/i);
                if (dkMatch) return dkMatch[1];
                // PC fax film
                const pcMatch = normalized.match(/^(PC\d{3})/i);
                if (pcMatch) return pcMatch[1];
                // BU belt unit â€” strip suffix
                const buMatch = normalized.match(/^(BU\d{3})/i);
                if (buMatch) return buMatch[1];
                // WT waste toner â€” strip suffix
                const wtMatch = normalized.match(/^(WT\d{3})/i);
                if (wtMatch) return wtMatch[1];
                // BT ink bottles â€” strip color suffix
                const btMatch = normalized.match(/^(BT\d{3,4})/i);
                if (btMatch) return btMatch[1];
                // HC high-capacity ink
                const hcMatch = normalized.match(/^(HC\d{2,4})/i);
                if (hcMatch) return hcMatch[1];
                // PRINK ribbon
                if (normalized.startsWith('PRINK')) return 'PRINK';
                return null;
            }
            // For Canon: PG/CL/PGI/CLI/BCI/GI/PFI (ink), CART (toner), FX (fax), EP, NPG, TG, GPR, T, LK, NB, MC, WT
            else if (brand === 'canon') {
                // Ink: PG, CL, PGI, CLI, BCI, GI, PFI â€” support single-digit and XXL
                const inkMatch = normalized.match(/^((?:PGI?|CLI?|BCI|GI|PFI)\d{1,4}(?:X{1,3}L)?)/i);
                if (inkMatch) return inkMatch[1];
                // Toner/drum: CART + number (strip color/HY suffixes, keep II)
                const cartMatch = normalized.match(/^(CART\d{3}(?:II)?)/i);
                if (cartMatch) return cartMatch[1];
                // FX fax series
                const fxMatch = normalized.match(/^(FX\d{1,2})/i);
                if (fxMatch) return fxMatch[1];
                // EP series
                const epMatch = normalized.match(/^(EP\d{2,3})/i);
                if (epMatch) return epMatch[1];
                // NPG series (strip color suffix)
                const npgMatch = normalized.match(/^(NPG\d{2,3})/i);
                if (npgMatch) return npgMatch[1];
                // TG/GPR series (strip color suffix)
                const tgMatch = normalized.match(/^(TG\d{2,3})/i);
                if (tgMatch) return tgMatch[1];
                const gprMatch = normalized.match(/^(GPR\d{2,3})/i);
                if (gprMatch) return gprMatch[1];
                // T series toner (T10, T12)
                const tMatch = normalized.match(/^(T\d{2})/i);
                if (tMatch) return tMatch[1];
                // LK, NB, MC, WT series
                const miscMatch = normalized.match(/^(LK\d{2,3}|NBCP\d[A-Z]*|MCG\d{2}|WT[A-Z]\d)/i);
                if (miscMatch) return miscMatch[1];
                // OEM alphanumeric part numbers (e.g., 3ED49A)
                const oemMatch = normalized.match(/^(\d[A-Z]{2}\d{2}[A-Z])/i);
                if (oemMatch) return oemMatch[1];
                return null;
            }
            // For Epson: T series, ERC ribbons, N-suffix codes
            else if (brand === 'epson') {
                const tMatch = normalized.match(/^(T\d{2,4}(?:X{1,3}L)?)/i);
                if (tMatch) return tMatch[1];
                const ercMatch = normalized.match(/^(ERC\d{2,3})/i);
                if (ercMatch) return ercMatch[1];
                // N-suffix codes (e.g., 73N, 81N)
                const nMatch = normalized.match(/^(\d{2,3}N)/i);
                if (nMatch) return nMatch[1];
                // Numeric codes (e.g., 502, 522, 277, 288)
                const numMatch = normalized.match(/^(\d{2,5})(?:XL)?/i);
                if (numMatch) return numMatch[1];
                return null;
            }
            // For HP: numeric codes, part number codes (CE, CF, CC, W, Q, C series), alphanumeric large format
            else if (brand === 'hp') {
                // Numeric codes like 05, 119, 143 (strip letter/XL suffix)
                const numMatch = normalized.match(/^(\d{2,3})(?:X{1,3}L)?[A-Z]?/i);
                if (numMatch) return numMatch[1];
                // Part number codes (CE505A, CF226X, CC530A, W2090A, Q3984A, C4096A)
                const partMatch = normalized.match(/^((?:CE|CF|CC|CZ|W|Q|C)\d{3,4})[A-Z]?/i);
                if (partMatch) return partMatch[1];
                // Alphanumeric large format codes (P2V68A, 3ED50A, L0R08A)
                const alphaMatch = normalized.match(/^([A-Z]\d[A-Z]\d{2})/i);
                if (alphaMatch) return alphaMatch[1];
                return null;
            }
            // For Samsung: MLT-D/R/W, CLT-C/K/M/Y/W/R/P, printer models (ML, CLP, CLX, SCX, SL)
            else if (brand === 'samsung') {
                // MLT/CLT toner codes â€” strip suffix letter (S/L/C etc.)
                const samsungMatch = normalized.match(/^((?:MLT[DRW]|CLT[CKMYWRP])\d{3})/i);
                if (samsungMatch) return samsungMatch[1];
                // Samsung printer model codes as fallback (ML1660, CLP360, CLX3305, etc.)
                const modelMatch = normalized.match(/^((?:ML|CLP|CLX|SCX|SL[MC]?)\d{3,5})/i);
                if (modelMatch) return modelMatch[1];
                return null;
            }
            // For Lexmark: 7-char alphanumeric codes (diverse formats)
            else if (brand === 'lexmark') {
                // Numeric-start 7-char codes: 20N3HC0, 50F3000, 71C1HC0, 78C6UCE, 12017SR, etc.
                const numMatch = normalized.match(/^(\d{2}[A-Z][A-Z0-9]{4,5})/i);
                if (numMatch) return numMatch[1];
                // Letter-prefix codes: C540H1CG, C236HK0, X203A11G, B226H00, E250A11P, T650A11P, W850H21G
                const letterMatch = normalized.match(/^([CBXETW]\d{2,4}[A-Z0-9]{2,5})/i);
                if (letterMatch) return letterMatch[1];
                return null;
            }
            // For OKI: B/C/MC model codes â€” strip DN suffix
            else if (brand === 'oki') {
                const okiMatch = normalized.match(/^([BCM]{1,2}\d{3,4})/i);
                if (okiMatch) return okiMatch[1];
                return null;
            }
            // For Fuji Xerox: CT, CWAA, Xerox numeric codes (106R, 108R), E/EC/EL prefix
            else if (brand === 'fuji-xerox') {
                const ctMatch = normalized.match(/^(CT\d{6})/i);
                if (ctMatch) return ctMatch[1];
                const cwaaMatch = normalized.match(/^(CWAA\d{4})/i);
                if (cwaaMatch) return cwaaMatch[1];
                // Xerox numeric codes: 106R01160, 108R00645, 013R00623
                const xeroxMatch = normalized.match(/^(\d{3}R\d{5})/);
                if (xeroxMatch) return xeroxMatch[1];
                // E/EC/EL prefix codes: E3300067, EC101791, EL300637
                const eMatch = normalized.match(/^(E[CL]?\d{5,6})/i);
                if (eMatch) return eMatch[1];
                return null;
            }
            // For Kyocera: TK (strip color suffix), DK, WT
            else if (brand === 'kyocera') {
                const tkMatch = normalized.match(/^(TK\d{3,4})/i);
                if (tkMatch) return tkMatch[1];
                const dkMatch = normalized.match(/^(DK\d{3,4})/i);
                if (dkMatch) return dkMatch[1];
                const wtMatch = normalized.match(/^(WT\d{3,4})/i);
                if (wtMatch) return wtMatch[1];
                return null;
            }
            // For other brands, try to extract a valid-looking code
            else {
                const genericMatch = normalized.match(/^([A-Z]{1,4}\d{1,6}(?:XL)?)/i);
                if (genericMatch) {
                    return genericMatch[1];
                }
            }

            return null; // Reject unrecognized codes
        },

        renderProductCodes(codes) {
            const grid = this.elements.codesGrid;
            grid.innerHTML = '';

            codes.forEach(({ code, count }) => {
                const box = document.createElement('button');
                box.className = 'drilldown-box drilldown-box--code';
                box.dataset.code = code;
                box.innerHTML = `
                    <span class="drilldown-box__code">${code}</span>
                    <span class="drilldown-box__count">${count} product${count > 1 ? 's' : ''}</span>
                `;
                box.addEventListener('click', () => this.navigateTo('products', { code }));
                grid.appendChild(box);
            });
        },

        async loadProducts(navVersion) {
            this.showLoading(true);

            try {
                const code = this.state.code;
                const categoryId = this.state.category;
                const typeKey = this.state.type || 'all';

                // Use the same cache key format as loadProductCodes (must match exactly!)
                const codesCacheKey = `${this.state.brand}-${categoryId}-${typeKey}-codes-v4-final`;

                // Get products from the cached codes (already filtered by category)
                let mergedProducts = [];
                if (this.cache.products[codesCacheKey]) {
                    // Find the code entry that matches our selected code
                    const cachedCodes = this.cache.products[codesCacheKey];
                    const codeEntry = cachedCodes.find(c => c.code === code);
                    if (codeEntry && codeEntry.products) {
                        mergedProducts = codeEntry.products;
                    }
                }

                // If no cached products, try to load them
                if (mergedProducts.length === 0) {
                    // Trigger loadProductCodes to populate cache, then get products
                    await this.loadProductCodes(navVersion);

                    // loadProductCodes shows the codes level as a side effect â€” hide it
                    // since we're on the products level, not codes
                    this.elements.levelCodes.hidden = true;

                    // Check if navigation changed
                    if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                    // Now try to get from cache again
                    if (this.cache.products[codesCacheKey]) {
                        const cachedCodes = this.cache.products[codesCacheKey];
                        const codeEntry = cachedCodes.find(c => c.code === code);
                        if (codeEntry && codeEntry.products) {
                            mergedProducts = codeEntry.products;
                        }
                    }
                }

                // Check if navigation changed before rendering
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                // Separate genuine and compatible using the API's source field (more reliable than name parsing)
                const isCompatibleProduct = (product) => {
                    // Primary: use API source field
                    if (product.source) {
                        return product.source === 'compatible';
                    }
                    // Fallback: check if name starts with "Compatible"
                    const productName = (product.name || '').toLowerCase().trim();
                    return productName.startsWith(this.compatiblePrefix);
                };

                let genuine = mergedProducts.filter(p => !isCompatibleProduct(p));
                let compatible = mergedProducts.filter(p => isCompatibleProduct(p));

                // Apply type filter if specified (from URL parameter)
                if (this.state.type === 'genuine') {
                    compatible = []; // Hide compatible products
                } else if (this.state.type === 'compatible') {
                    genuine = []; // Hide genuine products
                }

                // Extract and display product info (yield) and fetch compatible printers
                await this.displayProductInfo(mergedProducts);

                // Check if navigation changed before rendering
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                this.renderProducts(compatible, this.elements.compatibleProducts, this.elements.compatibleSection, true);
                this.renderProducts(genuine, this.elements.genuineProducts, this.elements.genuineSection, false);

                if (genuine.length === 0 && compatible.length === 0) {
                    this.showEmpty('No products found for this code.');
                } else {
                    this.elements.levelProducts.hidden = false;
                }
            } catch (error) {
                console.error('Failed to load products:', error);
                // Check if navigation changed
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;
                this.showEmpty('Failed to load products. Please try again.');
            }

            this.showLoading(false);
        },

        // Load products compatible with a specific printer
        async loadPrinterProducts(navVersion) {
            this.showLoading(true);

            try {
                // Fetch compatible products for the printer slug
                const response = await API.getProductsByPrinter(this.state.printer);

                // Check if navigation changed during fetch
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                if (response.success && response.data) {
                    const printerData = response.data.printer;
                    // API returns 'products' array (per product_pages.md documentation)
                    const products = response.data.products || response.data.compatible_products || [];

                    // Store printer name for display
                    this.state.printerName = printerData?.full_name || this.state.printer;

                    // Separate genuine and compatible using the API's source field (more reliable than name parsing)
                    const isCompatibleProduct = (product) => {
                        // Primary: use API source field
                        if (product.source) {
                            return product.source === 'compatible';
                        }
                        // Fallback: check if name starts with "Compatible"
                        const productName = (product.name || '').toLowerCase().trim();
                        return productName.startsWith(this.compatiblePrefix);
                    };

                    let genuine = products.filter(p => !isCompatibleProduct(p));
                    let compatible = products.filter(p => isCompatibleProduct(p));

                    // Apply type filter if specified (from URL parameter)
                    if (this.state.type === 'genuine') {
                        compatible = []; // Hide compatible products
                    } else if (this.state.type === 'compatible') {
                        genuine = []; // Hide genuine products
                    }

                    // Render compatible first, then genuine
                    this.renderProducts(compatible, this.elements.compatibleProducts, this.elements.compatibleSection, true);
                    this.renderProducts(genuine, this.elements.genuineProducts, this.elements.genuineSection, false);

                    if (genuine.length === 0 && compatible.length === 0) {
                        this.showEmpty('No compatible products found for this printer.');
                    } else {
                        this.elements.levelProducts.hidden = false;
                    }
                } else {
                    this.showEmpty('Failed to load compatible products for this printer.');
                }
            } catch (error) {
                console.error('Failed to load printer products:', error);
                // Check if navigation changed
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;
                this.showEmpty('Failed to load products. Please try again.');
            }

            this.showLoading(false);
        },

        // Mapping of printer models to compatible product codes
        printerProductCodes: {
            // Samsung
            'CLP-365': ['CLT-406', 'K406', 'C406', 'M406', 'Y406'],
            'CLP-415N': ['CLT-504', 'K504', 'C504', 'M504', 'Y504'],
            'CLX-3305': ['CLT-406', 'K406', 'C406', 'M406', 'Y406'],
            'CLX-4195FN': ['CLT-504', 'K504', 'C504', 'M504', 'Y504'],
            'ML-2165': ['MLT-D101', 'D101'],
            'ML-2955ND': ['MLT-D103', 'D103'],
            'Xpress M2020': ['MLT-D111', 'D111'],
            'Xpress M2070': ['MLT-D111', 'D111'],
            'Xpress C460FW': ['CLT-406', 'K406', 'C406', 'M406', 'Y406'],
            // Brother
            'DCP-135C': ['LC37', 'LC-37'],
            'DCP 135C': ['LC37', 'LC-37'],
            'DCP-150C': ['LC37', 'LC-37'],
            'DCP-330C': ['LC37', 'LC-37'],
            'DCP-540CN': ['LC37', 'LC-37'],
            'DCP-J140W': ['LC77', 'LC-77', 'LC73', 'LC-73'],
            'DCP-J4110DW': ['LC133', 'LC-133'],
            'DCP J4110DW': ['LC133', 'LC-133'],
            'MFC-230C': ['LC37', 'LC-37'],
            'MFC-240C': ['LC37', 'LC-37'],
            'MFC-J615W': ['LC77', 'LC-77', 'LC73', 'LC-73'],
            'MFC-J4510DW': ['LC133', 'LC-133'],
            'MFC J4510DW': ['LC133', 'LC-133'],
            'HL-2140': ['TN2150', 'TN-2150', 'DR2125', 'DR-2125'],
            'HL-2240D': ['TN2250', 'TN-2250', 'DR2225', 'DR-2225'],
            'HL-3040CN': ['TN240', 'TN-240'],
            // Canon
            'PIXMA iP4850': ['CLI-526', 'PGI-525'],
            'PIXMA MG5150': ['CLI-526', 'PGI-525'],
            'PIXMA MG5250': ['CLI-526', 'PGI-525'],
            'MAXIFY MB2050': ['PGI-1600', 'PGI1600'],
            'MAXIFY MB2350': ['PGI-1600', 'PGI1600'],
            // HP
            'DeskJet 1000': ['HP 61', '61XL', 'CH561', 'CH563'],
            'DeskJet 2050': ['HP 61', '61XL', 'CH561', 'CH563'],
            'ENVY 4500': ['HP 61', '61XL'],
            'ENVY 5530': ['HP 564', '564XL'],
            'OfficeJet 4630': ['HP 61', '61XL'],
            'LaserJet P1102': ['CE285A', '85A'],
            'LaserJet Pro M1212nf': ['CE285A', '85A'],
            // Epson
            'XP-200': ['200', 'T200'],
            'XP-400': ['200', 'T200'],
            'XP-600': ['277', 'T277'],
            'WF-2520': ['200', 'T200'],
            'WF-2540': ['200', 'T200'],
            'WF-3520': ['252', 'T252'],
            'WF-7510': ['252', 'T252']
        },

        async loadPrinterModelProducts(navVersion) {
            this.showLoading(true);

            try {
                const printerModel = this.state.printerModel;
                // Use printerBrand (from ink-finder) or fallback to brand parameter
                const printerBrand = this.state.printerBrand || this.state.brand;
                const brandName = this.brandInfo[printerBrand]?.name || printerBrand || '';

                // Store printer model name for display
                this.state.printerModelDisplay = printerModel;

                let allProducts = [];
                let inkCodes = []; // Ink codes to search for (e.g., "LC37")

                // Get or create Supabase client - ensure it's properly initialized
                let supabaseClient = null;
                try {
                    if (typeof Auth !== 'undefined' && Auth.supabase) {
                        supabaseClient = Auth.supabase;
                    } else if (typeof supabase !== 'undefined' && supabase.createClient && typeof Config !== 'undefined' && Config.SUPABASE_URL && Config.SUPABASE_ANON_KEY) {
                        // Create our own client if Auth isn't ready
                        supabaseClient = supabase.createClient(Config.SUPABASE_URL, Config.SUPABASE_ANON_KEY);
                    }
                } catch (clientError) {
                    // Supabase client creation failed - will fall back to API search
                }

                // Strategy 1: Query product_compatibility table via Supabase for compatible products
                if (supabaseClient) {
                    try {
                        let printerData = null;

                        // Try exact match first
                        const exactResult = await supabaseClient
                            .from('printer_models')
                            .select('id, full_name, model_name')
                            .ilike('full_name', printerModel)
                            .single();

                        if (exactResult.data) {
                            printerData = exactResult.data;
                        } else {
                            // Try partial match with wildcards
                            const partialResult = await supabaseClient
                                .from('printer_models')
                                .select('id, full_name, model_name')
                                .ilike('full_name', `%${printerModel}%`)
                                .limit(1);

                            if (partialResult.data && partialResult.data.length > 0) {
                                printerData = partialResult.data[0];
                            } else {
                                // Try searching by model_name only (without brand prefix)
                                const modelNameOnly = printerModel.replace(/^(BROTHER|CANON|EPSON|HP|SAMSUNG|LEXMARK|OKI|FUJI\s*XEROX|KYOCERA)\s+/i, '');

                                const modelResult = await supabaseClient
                                    .from('printer_models')
                                    .select('id, full_name, model_name')
                                    .ilike('model_name', modelNameOnly)
                                    .limit(1);

                                if (modelResult.data && modelResult.data.length > 0) {
                                    printerData = modelResult.data[0];
                                }
                            }
                        }

                        if (printerData) {
                            // Get all compatible product IDs
                            const { data: compatData, error: compatError } = await supabaseClient
                                .from('product_compatibility')
                                .select('product_id')
                                .eq('printer_model_id', printerData.id);

                            if (compatData && compatData.length > 0) {
                                const productIds = compatData.map(c => c.product_id);

                                // Fetch those products (these are the directly linked products)
                                const { data: productsData, error: productsError } = await supabaseClient
                                    .from('products')
                                    .select('*, brand:brands(name, slug)')
                                    .in('id', productIds)
                                    .eq('is_active', true);

                                if (productsData && productsData.length > 0) {
                                    allProducts = productsData.map(p => ({
                                        ...p,
                                        brand_name: p.brand?.name,
                                        brand_slug: p.brand?.slug
                                    }));

                                    // Extract ink codes from product names (e.g., "LC37", "PG-540", "LC133")
                                    // This helps us find compatible versions that aren't directly linked
                                    const codePattern = /\b([A-Z]{1,3}[-]?\d{2,4}[A-Z]{0,2})\b/gi;
                                    allProducts.forEach(p => {
                                        const matches = (p.name || '').match(codePattern);
                                        if (matches) {
                                            matches.forEach(code => {
                                                const upperCode = code.toUpperCase();
                                                if (!inkCodes.includes(upperCode)) {
                                                    inkCodes.push(upperCode);
                                                }
                                            });
                                        }
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        // Supabase query failed - will fall back to API search
                    }
                }

                // Strategy 2: Search for compatible products using the extracted ink codes
                if (inkCodes.length > 0 && supabaseClient) {
                    try {
                        // Search for products containing any of the ink codes
                        for (const code of inkCodes) {
                            // Search in product name
                            const { data: codeProducts, error: codeError } = await supabaseClient
                                .from('products')
                                .select('*, brand:brands(name, slug)')
                                .ilike('name', `%${code}%`)
                                .eq('is_active', true)
                                .limit(100);

                            if (codeProducts && codeProducts.length > 0) {
                                // Add products not already in the list
                                const existingIds = new Set(allProducts.map(p => p.id));
                                const newProducts = codeProducts
                                    .filter(p => !existingIds.has(p.id))
                                    .map(p => ({
                                        ...p,
                                        brand_name: p.brand?.name,
                                        brand_slug: p.brand?.slug
                                    }));
                                allProducts = [...allProducts, ...newProducts];
                            }

                            // Also search in SKU
                            const { data: skuProducts } = await supabaseClient
                                .from('products')
                                .select('*, brand:brands(name, slug)')
                                .ilike('sku', `%${code}%`)
                                .eq('is_active', true)
                                .limit(50);

                            if (skuProducts && skuProducts.length > 0) {
                                const existingIds = new Set(allProducts.map(p => p.id));
                                const newSkuProducts = skuProducts
                                    .filter(p => !existingIds.has(p.id))
                                    .map(p => ({
                                        ...p,
                                        brand_name: p.brand?.name,
                                        brand_slug: p.brand?.slug
                                    }));
                                allProducts = [...allProducts, ...newSkuProducts];
                            }
                        }
                    } catch (e) {
                        // Ink code search failed - continue with existing results
                    }
                }

                // Strategy 3: Fallback - search by printer model name via API
                if (allProducts.length === 0) {

                    // Search for the printer model name
                    const searchResponse = await API.getProducts({ search: printerModel, limit: 100 });

                    if (searchResponse.success && searchResponse.data?.products) {
                        allProducts = searchResponse.data.products;
                    }

                    // Also search for the brand name to get genuine products
                    if (brandName) {
                        const brandResponse = await API.getProducts({ search: brandName, limit: 100 });
                        if (brandResponse.success && brandResponse.data?.products) {
                            // Merge and deduplicate by ID
                            const existingIds = new Set(allProducts.map(p => p.id));
                            const newProducts = brandResponse.data.products.filter(p => !existingIds.has(p.id));
                            allProducts = [...allProducts, ...newProducts];
                        }
                    }
                }

                // Check if navigation changed during fetch
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                // Use static product code mapping only as a fallback when
                // Strategies 1-3 returned no results from the database
                let filteredProducts = allProducts;

                if (allProducts.length === 0) {
                    const modelNameOnly = printerModel.replace(/^(BROTHER|CANON|EPSON|HP|SAMSUNG|LEXMARK|OKI|FUJI\s*XEROX|KYOCERA)\s+/i, '');
                    const compatibleCodes = this.printerProductCodes[printerModel]
                        || this.printerProductCodes[modelNameOnly]
                        || this.printerProductCodes[modelNameOnly.replace(/\s+/g, '-')]
                        || [];

                    if (compatibleCodes.length > 0 && supabaseClient) {
                        try {
                            for (const code of compatibleCodes) {
                                const { data: codeProducts } = await supabaseClient
                                    .from('products')
                                    .select('*, brand:brands(name, slug)')
                                    .ilike('name', `%${code}%`)
                                    .eq('is_active', true)
                                    .limit(100);

                                if (codeProducts && codeProducts.length > 0) {
                                    const existingIds = new Set(filteredProducts.map(p => p.id));
                                    const newProducts = codeProducts
                                        .filter(p => !existingIds.has(p.id))
                                        .map(p => ({ ...p, brand_name: p.brand?.name, brand_slug: p.brand?.slug }));
                                    filteredProducts = [...filteredProducts, ...newProducts];
                                }
                            }
                        } catch (e) {
                            // Static code search failed
                        }
                    }
                }

                if (filteredProducts.length > 0) {

                    // Separate genuine and compatible using the API's source field (more reliable than name parsing)
                    const isCompatibleProduct = (product) => {
                        // Primary: use API source field
                        if (product.source) {
                            return product.source === 'compatible';
                        }
                        // Fallback: check if name starts with "Compatible"
                        const productName = (product.name || '').toLowerCase().trim();
                        return productName.startsWith(this.compatiblePrefix);
                    };

                    let genuine = filteredProducts.filter(p => !isCompatibleProduct(p));
                    let compatible = filteredProducts.filter(p => isCompatibleProduct(p));

                    // Apply type filter if specified (from URL parameter)
                    if (this.state.type === 'genuine') {
                        compatible = []; // Hide compatible products
                    } else if (this.state.type === 'compatible') {
                        genuine = []; // Hide genuine products
                    }

                    // Update section titles with printer model
                    this.elements.compatibleTitleText.textContent = `Compatible Products for ${printerModel}`;
                    this.elements.genuineTitleText.textContent = `Genuine/Original Products for ${printerModel}`;

                    // Render compatible first, then genuine
                    this.renderProducts(compatible, this.elements.compatibleProducts, this.elements.compatibleSection, true);
                    this.renderProducts(genuine, this.elements.genuineProducts, this.elements.genuineSection, false);

                    if (genuine.length === 0 && compatible.length === 0) {
                        this.showEmpty(`No compatible products found for ${printerModel}.`);
                    } else {
                        this.elements.levelProducts.hidden = false;
                    }
                } else {
                    this.showEmpty(`Failed to load compatible products for ${this.state.printerModel}.`);
                }
            } catch (error) {
                console.error('Failed to load printer model products:', error);
                // Check if navigation changed
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;
                this.showEmpty('Failed to load products. Please try again.');
            }

            this.showLoading(false);
        },

        async loadSearchResults(navVersion) {
            this.showLoading(true);

            try {
                const searchQuery = this.state.search;

                // Fetch products matching the search query, combined with any active filters
                const apiParams = {
                    search: searchQuery,
                    limit: 100
                };

                // Preserve brand filter if set
                if (this.state.brand) {
                    apiParams.brand = this.state.brand;
                }

                // Preserve category filter if set
                if (this.state.category) {
                    const categoryConfig = this.categories.find(c => c.id === this.state.category);
                    apiParams.category = categoryConfig?.apiCategory || this.state.category;
                }

                // Map URL 'type' parameter to API 'source' parameter for server-side filtering
                if (this.state.type === 'genuine' || this.state.type === 'compatible') {
                    apiParams.source = this.state.type;
                }
                const response = await API.getProducts(apiParams);

                // Check if navigation changed during fetch
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                let products = (response.success && response.data?.products) ? response.data.products : [];

                // Filter out irrelevant results where the search term only matches
                // as a substring of an unrelated word (e.g. "T10" in "Pla-t10-um")
                if (products.length > 0 && searchQuery.length <= 6) {
                    // Build a word-boundary regex for the search term
                    const escaped = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const wordBoundary = new RegExp(`(?:^|[\\s\\-\\/])${escaped}(?:[\\s\\-\\/BCMYK,.]|$)`, 'i');
                    const relevant = products.filter(p => {
                        const name = p.name || '';
                        const sku = p.sku || '';
                        const mpn = p.manufacturer_part_number || '';
                        return wordBoundary.test(name) || wordBoundary.test(sku) || wordBoundary.test(mpn)
                            || name.toLowerCase().includes(searchQuery.toLowerCase() + ' ')
                            || sku.toLowerCase().startsWith(searchQuery.toLowerCase());
                    });
                    // Only apply filter if it keeps some results
                    if (relevant.length > 0) products = relevant;
                }

                // If no product results, try searching for printer models
                // so queries like "dcp", "mfc 230", "pixma" find compatible products
                if (products.length === 0) {
                    try {
                        const printerResponse = await API.searchPrinters(searchQuery);
                        if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                        const printers = Array.isArray(printerResponse.data) ? printerResponse.data : [];
                        if (printers.length > 0) {
                            // If exactly one printer matched, redirect to printer model view
                            if (printers.length === 1) {
                                const printer = printers[0];
                                const modelName = printer.full_name || printer.model_name || '';
                                const brand = printer.brand?.name || printer.brand || '';
                                this.state.printerModel = modelName;
                                this.state.printerBrand = brand;
                                this.state.level = 'printer-model-products';
                                this.showLoading(false);
                                await this.loadPrinterModelProducts(navVersion);
                                return;
                            }

                            // Multiple printers matched â€” fetch products for each
                            const existingIds = new Set();
                            for (const printer of printers.slice(0, 5)) {
                                const slug = printer.slug;
                                if (!slug) continue;
                                try {
                                    const printerProducts = await API.getProductsByPrinter(slug);
                                    const pList = printerProducts.data?.products || printerProducts.data?.compatible_products || [];
                                    if (printerProducts.success && pList.length > 0) {
                                        for (const p of pList) {
                                            if (!existingIds.has(p.id)) {
                                                existingIds.add(p.id);
                                                products.push(p);
                                            }
                                        }
                                    }
                                } catch (e) { /* skip this printer */ }
                            }
                        }
                    } catch (e) {
                        // Printer search failed â€” continue with empty results
                    }
                }

                if (products.length > 0) {
                    // Try to detect the brand from search results
                    let detectedBrand = null;

                    for (const product of products) {
                        const productName = (product.name || '').toLowerCase();
                        const productNameNoSpace = productName.replace(/[\s-]/g, '');
                        for (const [brandKey, brandData] of Object.entries(this.brandInfo)) {
                            const brandNameLower = brandData.name.toLowerCase();
                            const brandNameNoSpace = brandNameLower.replace(/[\s-]/g, '');
                            if (productName.includes(brandNameLower) || productNameNoSpace.includes(brandNameNoSpace)) {
                                detectedBrand = brandKey;
                                break;
                            }
                        }
                        if (detectedBrand) break;
                    }

                    // Filter products by detected brand if found (to keep results consistent)
                    let filteredProducts = products;
                    if (detectedBrand) {
                        const brandNameLower = this.brandInfo[detectedBrand].name.toLowerCase();
                        const brandNameNoSpace = brandNameLower.replace(/[\s-]/g, '');
                        filteredProducts = products.filter(p => {
                            const name = (p.name || '').toLowerCase();
                            const nameNoSpace = name.replace(/[\s-]/g, '');
                            return name.includes(brandNameLower) || nameNoSpace.includes(brandNameNoSpace);
                        });
                        // If brand filtering removed all, keep original
                        if (filteredProducts.length === 0) filteredProducts = products;
                    }

                    // Separate genuine and compatible
                    const isCompatibleProduct = (product) => {
                        if (product.source) return product.source === 'compatible';
                        const productName = (product.name || '').toLowerCase().trim();
                        return productName.startsWith(this.compatiblePrefix);
                    };

                    let genuine = filteredProducts.filter(p => !isCompatibleProduct(p));
                    let compatible = filteredProducts.filter(p => isCompatibleProduct(p));

                    // Apply type filter if specified
                    if (this.state.type === 'genuine') {
                        compatible = [];
                    } else if (this.state.type === 'compatible') {
                        genuine = [];
                    }

                    // Update section titles
                    const brandDisplay = detectedBrand ? this.brandInfo[detectedBrand].name + ' ' : '';
                    this.elements.compatibleTitleText.textContent = `${brandDisplay}Compatible Products for "${searchQuery}"`;
                    this.elements.genuineTitleText.textContent = `${brandDisplay}Original Products for "${searchQuery}"`;

                    await this.displayProductInfo(filteredProducts);

                    if (navVersion !== undefined && this.navigationVersion !== navVersion) return;

                    this.renderProducts(compatible, this.elements.compatibleProducts, this.elements.compatibleSection, true);
                    this.renderProducts(genuine, this.elements.genuineProducts, this.elements.genuineSection, false);

                    if (genuine.length === 0 && compatible.length === 0) {
                        this.showEmpty(`No products found for "${searchQuery}".`);
                    } else {
                        this.elements.levelProducts.hidden = false;
                    }
                } else {
                    this.showEmpty(`No products found for "${searchQuery}".`);
                }
            } catch (error) {
                console.error('Failed to search products:', error);
                if (navVersion !== undefined && this.navigationVersion !== navVersion) return;
                this.showEmpty('Failed to search products. Please try again.');
            }

            this.showLoading(false);
        },

        // Get color style (delegates to shared ProductColors utility)
        getColorStyle(colorName) {
            // Use shared utility with default gray fallback for unknown colors
            return ProductColors.getStyle(colorName, 'background-color: #e0e0e0;');
        },

        // Check if product is a value pack / multi-pack
        isValuePack(product) {
            const name = (product.name || '').toLowerCase();
            const color = (product.color || '').toLowerCase();

            // Check for value packs / multi-packs
            if (name.includes('value pack') || name.includes('combo') || name.includes('bundle') ||
                name.includes('multi') || name.includes('-pack') || name.includes(' pack')) {
                return true;
            }

            // Check for multi-color (CMY, BCMY, etc.)
            if (color === 'cmy' || color === 'bcmy' || color === 'cmyk' ||
                color.includes('tri-colo') || color === 'color' || color === 'colour') {
                return true;
            }

            return false;
        },

        // Sort products: singles by color first, then value packs at the end
        sortProducts(products) {
            const colorOrder = ['black', 'photo black', 'matte black', 'cyan', 'light cyan',
                               'magenta', 'light magenta', 'yellow', 'red', 'blue', 'green',
                               'gray', 'grey', 'light gray', 'light grey'];

            return products.sort((a, b) => {
                const aIsValuePack = this.isValuePack(a);
                const bIsValuePack = this.isValuePack(b);

                // Value packs go to the end
                if (aIsValuePack && !bIsValuePack) return 1;
                if (!aIsValuePack && bIsValuePack) return -1;

                // Both are value packs or both are singles - sort by color
                const colorA = (a.color || '').toLowerCase();
                const colorB = (b.color || '').toLowerCase();
                const indexA = colorOrder.indexOf(colorA);
                const indexB = colorOrder.indexOf(colorB);

                // If color not in order list, put at end of its group
                const orderA = indexA === -1 ? 999 : indexA;
                const orderB = indexB === -1 ? 999 : indexB;

                return orderA - orderB;
            });
        },

        renderProducts(products, container, section, isCompatible = false) {
            container.innerHTML = '';

            if (products.length === 0) {
                section.hidden = true;
                return;
            }

            section.hidden = false;

            // Sort products: singles by color, then value packs at end
            const sortedProducts = this.sortProducts([...products]);

            // Render all products in a single wrapping grid
            sortedProducts.forEach(product => {
                const card = this.createProductCard(product, isCompatible);
                container.appendChild(card);
            });
        },

        createProductCard(product, isCompatible) {
            const card = document.createElement('article');
            card.className = 'product-card';

            // Use retail_price from backend API
            const price = product.retail_price || 0;
            const inStock = product.in_stock === true;
            const brandName = product.brand?.name || '';
            const color = product.color || '';

            // Keep full product name including "Compatible" prefix
            const displayName = product.name || '';

            // For compatible products, show color block instead of image
            let imageContent;
            if (isCompatible) {
                const colorStyle = this.getColorStyle(color);
                imageContent = `<div class="product-card__color-block" style="${colorStyle}"></div>`;
            } else {
                imageContent = product.image_url
                    ? `<img src="${product.image_url}" alt="${product.name}" loading="lazy">`
                    : `<svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                        <rect x="6" y="2" width="12" height="20" rx="2"/>
                        <path d="M9 6h6M9 10h6"/>
                    </svg>`;
            }

            // Check if product is already a favourite
            const isFav = typeof Favourites !== 'undefined' && Favourites.isFavourite && Favourites.isFavourite(product.id);

            card.innerHTML = `
                <a href="/html/product/index.html?sku=${product.sku}" class="product-card__link">
                    <div class="product-card__image">
                        ${imageContent}
                    </div>
                    <div class="product-card__content">
                        <h3 class="product-card__title">${displayName}</h3>
                        ${color ? `<span class="product-card__color">${color}</span>` : ''}
                        <div class="product-card__pricing">
                            <span class="product-card__price">${formatPrice(price)}</span>
                        </div>
                        <span class="product-card__stock ${inStock ? 'product-card__stock--in' : 'product-card__stock--out'}">
                            ${inStock ? 'In Stock' : 'Out of Stock'}
                        </span>
                    </div>
                </a>
                <button type="button" class="favourite-btn product-card__fav-btn ${isFav ? 'favourite-btn--active' : ''}"
                        data-product-id="${product.id}"
                        data-product-sku="${product.sku || ''}"
                        data-product-name="${displayName}"
                        data-product-price="${price}"
                        data-product-image="${product.image_url || ''}"
                        data-product-brand="${brandName}"
                        data-product-color="${color}"
                        aria-pressed="${isFav}"
                        title="${isFav ? 'Remove from favourites' : 'Add to favourites'}">
                    <svg class="favourite-btn__icon favourite-btn__icon--outline" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                    <svg class="favourite-btn__icon favourite-btn__icon--filled" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                </button>
                <button class="btn btn--primary btn--sm product-card__cart-btn"
                        data-product-id="${product.id}"
                        aria-label="Add ${displayName} to cart"
                        ${!inStock ? 'disabled' : ''}>
                    Add to Cart
                </button>
            `;

            // Add cart button event listener
            const cartBtn = card.querySelector('.product-card__cart-btn');
            cartBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.addToCart(product, cartBtn);
            });

            return card;
        },

        // Add to cart functionality using Cart.addItem (server-first)
        async addToCart(product, button) {
            const originalText = button.textContent;
            button.textContent = 'Adding...';
            button.disabled = true;

            try {
                // Use Cart.addItem - server-first for authenticated users,
                // localStorage for guest users
                await Cart.addItem({
                    id: product.id,
                    name: product.name,
                    price: product.retail_price || 0,
                    sku: product.sku || '',
                    image: product.image_url || '',
                    brand: product.brand?.name || '',
                    color: product.color || '',
                    quantity: 1
                });

                button.textContent = 'Added!';
                button.classList.add('btn--success');

                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn--success');
                    button.disabled = false;
                }, 1500);
            } catch (error) {
                console.error('Add to cart error:', error);
                button.textContent = 'Error';
                button.classList.add('btn--error');

                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn--error');
                    button.disabled = false;
                }, 2000);
            }
        },

        // =========================================
        // UI UPDATES
        // =========================================
        updateBreadcrumb() {
            const list = this.elements.breadcrumbList;
            list.innerHTML = '';

            // Always show Shop
            const shopItem = this.createBreadcrumbItem('Shop', this.state.level === 'brands', () => {
                this.navigateTo('brands');
            });
            list.appendChild(shopItem);

            // Brand level
            if (this.state.brand) {
                const brandName = this.brandInfo[this.state.brand]?.name || this.state.brand;
                const isCurrent = this.state.level === 'categories';
                const brandItem = this.createBreadcrumbItem(brandName, isCurrent, () => {
                    this.navigateTo('categories', { brand: this.state.brand });
                });
                list.appendChild(brandItem);
            }

            // Category level
            if (this.state.category) {
                const cat = this.categories.find(c => c.id === this.state.category);
                const catName = cat?.name || this.state.category;
                const isCurrent = this.state.level === 'codes';
                const catItem = this.createBreadcrumbItem(catName, isCurrent, () => {
                    this.navigateTo('codes', { category: this.state.category });
                });
                list.appendChild(catItem);
            }

            // Code level
            if (this.state.code) {
                const codeItem = this.createBreadcrumbItem(this.state.code, true);
                list.appendChild(codeItem);
            }

            // Printer level (special case for printer-based navigation)
            if (this.state.printer) {
                const printerItem = this.createBreadcrumbItem(this.state.printerName || this.state.printer, true);
                list.appendChild(printerItem);
            }

            // Printer model level (from ink finder)
            if (this.state.printerModel) {
                const printerModelItem = this.createBreadcrumbItem(this.state.printerModelDisplay || this.state.printerModel, true);
                list.appendChild(printerModelItem);
            }

            // Search results level
            if (this.state.search) {
                const searchItem = this.createBreadcrumbItem(`Search: "${this.state.search}"`, true);
                list.appendChild(searchItem);
            }
        },

        createBreadcrumbItem(text, isCurrent, onClick = null) {
            const li = document.createElement('li');
            li.className = 'drilldown-breadcrumb__item';

            if (isCurrent) {
                li.classList.add('drilldown-breadcrumb__item--current');
                li.innerHTML = `<span>${text}</span>`;
            } else {
                const link = document.createElement('button');
                link.className = 'drilldown-breadcrumb__link';
                link.textContent = text;
                if (onClick) link.addEventListener('click', onClick);
                li.appendChild(link);
            }

            return li;
        },

        // Get product type label based on category and type filter
        getProductTypeLabel() {
            const typeMap = {
                'ink': 'Inkjet Cartridges',
                'toner': 'Toner Cartridges',
                'consumable': 'Drums & Supplies'
            };
            let label = typeMap[this.state.category] || 'Cartridges';

            // Add type filter prefix if specified
            if (this.state.type === 'genuine') {
                label = 'Original ' + label;
            } else if (this.state.type === 'compatible') {
                label = 'Compatible ' + label;
            }

            return label;
        },

        // Display compatible printers and yield info, update section titles
        async displayProductInfo(products) {
            // Reset banners
            this.elements.printersBanner.hidden = true;
            this.elements.yieldBanner.hidden = true;

            // Get brand name and product type for section titles
            const brandName = this.brandInfo[this.state.brand]?.name || this.state.brand || '';
            const productType = this.getProductTypeLabel();

            // Update section titles with brand name
            this.elements.compatibleTitleText.textContent = `${brandName} Compatible ${productType}`;
            this.elements.genuineTitleText.textContent = `${brandName} Original ${productType}`;

            if (!products || products.length === 0) return;

            // Get yield/page count from products
            let yieldValue = null;
            products.forEach(product => {
                if (!yieldValue && product.page_yield) {
                    yieldValue = product.page_yield;
                }
                if (!yieldValue && product.yield) {
                    yieldValue = product.yield;
                }
                if (!yieldValue && product.pages) {
                    yieldValue = product.pages;
                }
            });

            // Display yield if found
            if (yieldValue) {
                const yieldText = typeof yieldValue === 'number'
                    ? `Approx. ${yieldValue.toLocaleString()} pages`
                    : yieldValue;
                this.elements.yieldValue.textContent = yieldText;
                this.elements.yieldBanner.hidden = false;
            }

            // Fetch compatible printers from API using first product's SKU
            const firstProduct = products.find(p => p.sku);
            if (firstProduct && firstProduct.sku) {
                try {
                    const response = await API.getCompatiblePrinters(firstProduct.sku);
                    if (response.success && response.data) {
                        const printers = response.data.printers || response.data.compatible_printers || response.data;

                        if (Array.isArray(printers) && printers.length > 0) {
                            // Extract printer info with names and brands
                            const printerInfo = printers.map(p => {
                                if (typeof p === 'string') return { name: p, brand: '' };
                                const name = p.full_name || p.model_name || p.name || p.model || '';
                                const brand = p.brand_name || p.brand || '';
                                return { name, brand };
                            }).filter(p => p.name).sort((a, b) => a.name.localeCompare(b.name));

                            if (printerInfo.length > 0) {
                                const links = printerInfo.map(p => {
                                    const params = new URLSearchParams({ printer_model: p.name });
                                    if (p.brand) params.set('printer_brand', p.brand);
                                    const escapedName = p.name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                                    return `<a href="/html/shop.html?${params}" class="printer-link">${escapedName}</a>`;
                                }).join(', ');
                                this.elements.printersList.innerHTML = links;
                                this.elements.printersBanner.hidden = false;
                            }
                        }
                    }
                } catch (error) {
                    // Could not fetch compatible printers - continue without them
                }
            }
        },

        updateTitle() {
            // Hide product type label by default
            this.elements.productTypeLabel.hidden = true;

            if (this.state.level === 'products' || this.state.level === 'printer-products' || this.state.level === 'printer-model-products' || this.state.level === 'search-results') {
                // Hide main title on products level
                this.elements.title.hidden = true;

                // Show product type inline with breadcrumb
                let productType = this.getProductTypeLabel();
                if (this.state.level === 'printer-model-products') {
                    productType = 'Compatible Products';
                } else if (this.state.level === 'search-results') {
                    productType = 'Search Results';
                }
                this.elements.productTypeLabel.textContent = productType;
                this.elements.productTypeLabel.hidden = false;
                // Note: yieldBanner is shown/hidden by displayProductInfo based on data
            } else {
                // Show main title on other levels
                this.elements.title.hidden = false;
                // Hide yield banner on non-product levels
                this.elements.yieldBanner.hidden = true;

                const titles = {
                    brands: 'Select a Brand',
                    categories: `${this.brandInfo[this.state.brand]?.name || ''} - Select a Category`,
                    codes: `Select a Product Code`
                };

                this.elements.title.textContent = titles[this.state.level] || '';
            }
        }
    };

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        DrilldownNav.init();
    });
    </script>

    <!-- ============================================
         FOOTER
         ============================================ -->
    <footer class="site-footer">
        <div class="footer-main">
            <div class="container">
                <div class="footer-grid">
                    <!-- Brand column -->
                    <div class="footer-brand">
                        <a href="/html/index.html" class="footer-brand__logo">
                            <span class="logo__text">Ink<span>Cartridges</span>.co.nz</span>
                        </a>
                        <p class="footer-brand__description">
                            New Zealand's trusted source for quality printing supplies.
                            We help homes and businesses keep printing with genuine and
                            compatible ink and toner cartridges.
                        </p>
                        <div class="footer-brand__social">
                            <a href="#" aria-label="Facebook">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/></svg>
                            </a>
                            <a href="#" aria-label="Instagram">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/></svg>
                            </a>
                            <a href="#" aria-label="LinkedIn">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
                            </a>
                        </div>
                    </div>

                    <!-- Support column -->
                    <div class="footer-column">
                        <h3 class="footer-column__heading">Support</h3>
                        <ul class="footer-links">
                            <li><a href="/html/contact.html">Contact Us</a></li>
                            <li><a href="/html/faq.html">FAQs</a></li>
                            <li><a href="/html/returns.html">Returns & Refunds</a></li>
                            <li><a href="/html/about.html">About Us</a></li>
                            <li><a href="/html/business.html">Business Accounts</a></li>
                        </ul>
                    </div>

                    <!-- Contact column -->
                    <div class="footer-column">
                        <h3 class="footer-column__heading">Contact</h3>
                        <ul class="footer-links">
                            <li>
                                <strong>Phone:</strong><br>
                                <a href="tel:0800465275">0800 INK KART (465 275)</a>
                            </li>
                            <li>
                                <strong>Email:</strong><br>
                                <a href="mailto:support@inkcartridges.co.nz">support@inkcartridges.co.nz</a>
                            </li>
                            <li>
                                <strong>Hours:</strong><br>
                                8am - 8pm, 7 days a week
                            </li>
                        </ul>
                    </div>
                </div>

                <!-- Trust badges -->
                <div class="footer-trust">
                    <div class="footer-trust__item">
                        <svg class="footer-trust__icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                        <span>100% NZ Owned</span>
                    </div>
                    <div class="footer-trust__item">
                        <svg class="footer-trust__icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                        <span>Secure Checkout</span>
                    </div>
                    <div class="footer-trust__item">
                        <svg class="footer-trust__icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="1" y="3" width="15" height="13"/><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"/><circle cx="5.5" cy="18.5" r="2.5"/><circle cx="18.5" cy="18.5" r="2.5"/></svg>
                        <span>Fast NZ Delivery</span>
                    </div>
                    <div class="footer-trust__item">
                        <svg class="footer-trust__icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                        <span>NZ-Based Support</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer-bottom">
            <div class="container">
                <p class="footer-copyright">
                    &copy; <span id="current-year">2025</span> InkCartridges.co.nz. All rights reserved.
                </p>
                <div class="footer-legal">
                    <a href="/html/privacy.html">Privacy Policy</a>
                    <a href="/html/terms.html">Terms & Conditions</a>
                </div>
                <div class="footer-payment">
                    <span class="footer-payment__label">We accept:</span>
                    <div class="footer-payment__icons">
                        <span title="Visa">Visa</span>
                        <span title="Mastercard">MC</span>
                        <span title="PayPal">PayPal</span>
                        <span title="Afterpay">Afterpay</span>
                        <span title="POLi">POLi</span>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="/js/config.js"></script>
    <script src="/js/security.js"></script>
    <script src="/js/api.js"></script>
    <script src="/js/utils.js"></script>
    <script src="/js/auth.js"></script>
    <script src="/js/cart.js"></script>
    <script src="/js/favourites.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/mega-nav.js"></script>
    <script src="/js/modern-effects.js"></script>
    <script src="/js/analytics.js"></script>
</body>
</html>
